接触git之后,深深感到之前SVN代码提交的是多么简单,一步到位;
个人实践理解:
一.我们首先要有一个个人仓库(可以自己新建,也可以FORK别人)
二.我们将个人仓库(或者别人仓库,如果别人给你开了权限的话)clone下来,就可以在自己电脑上尽情摧残我们的的库了.

clone下来的东西,主要分三块,工作区,暂存区,版本库;网上有关系图;

正常流程:

本地修改文件->git status 查看差异->git add 添加修改文件到暂存区-> git commit 暂存区提交到版本库 ->git push 将版本库推到个人仓;

git status 会展示 被标记和未被标记的有差异的内容(tracked untracked 标记 未标记 就是直接看文件下面有没有绿 红这种标记,个人理解,如果是新加文件,要ADD标记一下)

git add   可以用 *.js 等通配符添加文件 或者全路径添加,暂时没遇到更好的方法;

git commit 一般加 -m "巴拉巴拉"的描述内容;

git push + origin *** 推送到对应分支 

这是很顺利的流程,网上的git都是根据命令来教怎么用,对于我这种菜鸟还是很难理解的;


常用命令:
git log 查看 commit记录   --oneline 一条显示  --number  显示条数

git diff 

git commit --amend 增补提交. 会使用与当前提交节点相同的父节点进行一次新的提交,旧的提交将会被取消.

当add或者commit错了,可以用reset重置
git reset --mixed id,是将git的HEAD变了(也就是提交记录变了),但文件并没有改变，(也就是working tree并没有改变). 取消了commit和add的内容.
git reset --soft id. 实际上，是git reset –mixed id 后,又做了一次git add.即取消了commit的内容.
git reset --hard id.是将git的HEAD变了,文件也变了.
按改动范围排序如下:
soft (commit) < mixed (commit + add) < hard (commit + add + local working)

HEAD 指向版本库的当前版本;HEAD值和最新commit 的ID是一样一样的;HEAD就是指向最新的一次commit;
git reflog 展示HEAD变化

